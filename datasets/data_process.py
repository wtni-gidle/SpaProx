from typing import Optional, Union
import numpy as np
from itertools import combinations, product
from . import utils
from anndata import AnnData


class BaseData:
    """
    Base class for data processing.

    Warning
    -------
    This class should not be used directly. Use derived classes instead.
    """
    def __init__(self, adata: AnnData, spot_index: Optional[np.ndarray] = None) -> None:
        self.adata = adata
        if spot_index is None:
            spot_index = np.arange(len(adata))
        self.spot_index = spot_index

        self.spot2pair()

    def spot2pair(self) -> None:
        """
        Generate `pair_index_total` and `total_index`.
        """
        self.pair_index_total = None
        self.total_index = np.arange(len(self.pair_index_total))

        raise NotImplementedError('spot2pair needs to be redefined')
    
    def get_count(self) -> None:
        """
        Generate `count`.
        """
        self.count = None
        raise NotImplementedError('get_count needs to be redefined')

    def get_data(self) -> None:
        """
        Generate `data_index` and `pair_index`. Take the total data by default.
        """
        self.data_index = self.total_index
        self.pair_index = self.pair_index_total
    
    def pop(self, obj: Union[list, np.ndarray]) -> None:
        """
        Reduce `data_index` and `pair_index` by `obj`.
        """
        self.data_index = np.delete(self.data_index, obj, 0)
        self.pair_index = np.delete(self.pair_index, obj, 0)
        
    def update(self, obj: Union[list, np.ndarray]) -> None:
        """
        Update `data_index` and `pair_index` by `obj`.
        """
        self.data_index = np.take(self.data_index, obj, 0)
        self.pair_index = np.take(self.pair_index, obj, 0)
 
    def get_feature(self, index: np.ndarray, copy: bool = False) -> Optional[np.ndarray]:
        """
        Get `feature` according to `index`.

        Parameters
        ----------
        index : np.ndarray
            Spot pair index of shape (N, 2).

        copy : bool, default=False
            Whether to return `feature`.
        """
        feature = np.apply_along_axis(
            lambda x:np.concatenate((self.count[x[0]], self.count[x[1]])), 
            1,
            index
        )
        if copy:
            return feature
        else:
            self.feature = feature
    
    def preprocess(
        self, 
        adata: AnnData,
        gene: Union[np.ndarray, list], 
        normalize: bool = True, 
        log1p: bool = True, 
        scale: bool = True
    ) -> AnnData:
        """
        See :ref:`utils.preprocess`.
        """
        return utils.preprocess(
            adata, 
            gene = gene,
            normalize = normalize,
            log1p = log1p,
            scale = scale
        )



class UnlabeledDataUnit(BaseData):
    """
    Unlabeled data processing class for single set of spots.

    An unlabeled data unit can be subsequently used to build dataset in a single cell prediction task.
    Given `adata` and `spot_index`, it can generate spot pairs and obtain features. Preprocessing is an optional step.

    Parameters
    ----------
    adata : AnnData
        The original data.
    
    spot_index : Optional[np.ndarray], default=None
        The spot subset index of `adata`. If None, `spot_index` is the total spot index of `adata`.
    
    Attributes
    ----------
    adata : AnnData
        The original data.

    spot_index : np.ndarray
        The spot subset index of `adata`.
    
    pair_index_total : np.ndarray
        2D `np.ndarray` of shape :math:`n_pairs` x 2, each row records the spot index of `spot pair`. 
        :math:`n_pairs = n_spots x (n_spots - 1) / 2`. 
        Note that the recorded index is not the `spot_index` in `adata`, but the index of `spot_index`.
        Users can restore the original `pair_index_total` by indexing the `spot_index` using `pair_index_total`.
    
    total_index : np.ndarray
        The total data index.

    pair_index : np.ndarray
        The spot pair index used to build dataset, equivalent to `pair_index_total` in this class.

    data_index : np.ndarray
        The data index used to build dataset, equivalent to `total_index` in this class.

    count : np.ndarray
        The (preprocessed) count of `adata` subset.
    
    feature : np.ndarray
        The features generated by `pair_index`.
    """
    def spot2pair(self) -> None:
        """
        Generate `pair_index_total` and `total_index`.
        """
        self.pair_index_total = np.array(list(
            combinations(
                range(len(self.spot_index)), 2
            )
        ))
        self.total_index = np.arange(len(self.pair_index_total))
    
    def get_count(self, preprocess = True, **kwargs) -> None:
        """
        Generate `count`.
        """
        adata_sub = self.adata[self.spot_index].copy()
        if preprocess:
            adata_sub = self.preprocess(adata_sub, **kwargs)

        self.count = adata_sub.to_df().values
    
    def get_feature(self, index: Optional[np.ndarray] = None, copy: bool = False) -> Optional[np.ndarray]:
        """
        Get `feature` according to `index`.

        Parameters
        ----------
        index : Optional[np.ndarray], default=None
            Spot pair index of shape (N, 2). If None, take `pair_index`.

        copy : bool, default=False
            Whether to return `feature`.
        """
        if index is None:
            index = self.pair_index

        return super().get_feature(index, copy)



class UnlabeledDataDoublet(BaseData):
    """
    Unlabeled data processing class for two sets of spots.

    An unlabeled data doublet can be subsequently used for prediction tasks between two slices.
    Given `adata` and `spot_index`, it can generate spot pairs and obtain features. Preprocessing is an optional step.
    
    Parameters
    ----------
    adata1 : AnnData
        The slice 1.

    adata2 : AnnData
        The slice 2.
    
    spot_index1 : Optional[np.ndarray], default=None
        The spot subset index of `adata1`. If None, `spot_index1` is the total spot index of `adata1`.
    
    spot_index2 : Optional[np.ndarray], default=None
        The spot subset index of `adata2`. If None, `spot_index2` is the total spot index of `adata2`.
    
    Attributes
    ----------
    adata1 : AnnData
        The slice 1.

    adata2 : AnnData
        The slice 2.
    
    spot_index1 : np.ndarray
        The spot subset index of `adata1`.
    
    spot_index2 : np.ndarray
        The spot subset index of `adata2`.
    
    pair_index_total : np.ndarray
        2D `np.ndarray` of shape :math:`n_pairs` x 2, each row records the spot index of `spot pair`. 
        :math:`n_pairs = n_spot1 x n_spot2`. 
        Note that the recorded index is not the `spot_index` in `adata`, but the index of 
        `spot_index1` and `spot_index2`. Users can restore the original `pair_index_total` 
        by indexing the `spot_index1` and `spot_index2` using `pair_index_total`.
    
    total_index : np.ndarray
        The total data index.

    pair_index : np.ndarray
        The spot pair index used to build dataset, equivalent to `pair_index_total` in this class.

    data_index : np.ndarray
        The data index used to build dataset, equivalent to `total_index` in this class.

    count1 : np.ndarray
        The (preprocessed) count of `adata1` subset.
    
    count2 : np.ndarray
        The (preprocessed) count of `adata2` subset.

    feature : np.ndarray
        The features generated by `pair_index`.
    """
    def __init__(
        self,
        adata1: AnnData, 
        adata2: AnnData,
        spot_index1: Optional[np.ndarray] = None,
        spot_index2: Optional[np.ndarray] = None
    ) -> None:
        if spot_index1 is None:
            spot_index1 = np.arange(len(adata1))
        self.spot_index1 = spot_index1

        if spot_index2 is None:
            spot_index2 = np.arange(len(adata2))
        self.spot_index2 = spot_index2

        self.adata1 = adata1
        self.adata2 = adata2
        
        self.spot2pair()
    
    def spot2pair(self) -> None:
        """
        Generate `pair_index_total` and `total_index`.
        """
        self.pair_index_total = np.array(list(
            product(
                range(len(self.spot_index1)), range(len(self.spot_index2))
            )
        ))
        self.total_index = np.arange(len(self.pair_index_total))
    
    def get_count(self, preprocess = True, **kwargs) -> None:
        """
        Generate `count1` and `count2`.
        """
        # 分别进行scale
        adata1_sub = self.adata1[self.spot_index1].copy()
        if preprocess:
            adata1_sub = self.preprocess(adata1_sub, **kwargs)
        
        adata2_sub = self.adata2[self.spot_index2].copy()
        if preprocess:
            adata2_sub = self.preprocess(adata2_sub, **kwargs)

        self.count1 = adata1_sub.to_df().values
        self.count2 = adata2_sub.to_df().values

    def get_feature(self, index: Optional[np.ndarray] = None, copy: bool = False) -> Optional[np.ndarray]:
        """
        Get `feature` according to `index`.

        Parameters
        ----------
        index : Optional[np.ndarray], default=None
            Spot pair index of shape (N, 2). If None, take `pair_index`.

        copy : bool, default=False
            Whether to return `feature`.
        """
        if index is None:
            index = self.pair_index
            
        feature = np.apply_along_axis(
            lambda x:np.concatenate((self.count1[x[0]], self.count2[x[1]])), 
            1,
            index
        )
        if copy:
            return feature
        else:
            self.feature = feature



class LabeledData(BaseData):
    """
    Labeled data processing class.

    Warning
    -------
    This class should not be used directly. Use derived classes instead.
    """
    def __init__(
        self, 
        adata: AnnData, 
        neighbor_dis: float, 
        spot_index: Optional[np.ndarray] = None
    ) -> None:
        super().__init__(adata, spot_index)
        self.neighbor_dis = neighbor_dis
    
    def calc_distance(self) -> None:
        """
        Calculate `distance`.
        """
        adata_sub = self.adata[self.spot_index].copy()
        self.distance = utils.distance(adata_sub, pair_index = self.pair_index_total)

        self.label_total = self.distance <= self.neighbor_dis

    def get_pos(self) -> None:
        """
        Get positive sample. Generate `pos_index` and `pair_index_pos`.
        """
        self.pos_index = np.compress(self.label_total, self.total_index, 0)
        self.pair_index_pos = np.take(self.pair_index_total, self.pos_index, 0)
        
    def get_neg(self, neg_size: Optional[float] = None) -> None:
        """
        Get negative sample. Generate `neg_index` and `pair_index_neg`. Random downsampling is optional.
        """
        pos_num = sum(self.label_total)

        if neg_size:
            self.neg_index = np.random.choice(
                self.total_index[~self.label_total], 
                int(neg_size * pos_num), 
                replace = False
            )
        else:
            self.neg_index = np.compress(~self.label_total, self.total_index, 0)

        self.pair_index_neg = np.take(self.pair_index_total, self.neg_index, 0)

    def get_data(self, neg_size: Optional[float] = None) -> None:
        """
        Generate `data_index` and `pair_index`.
        """
        self.get_pos()
        self.get_neg(neg_size = neg_size)
        self.data_index = np.concatenate((self.pos_index, self.neg_index))
        self.pair_index = np.take(self.pair_index_total, self.data_index, 0)
    
    def mirror_copy(self) -> None:
        """
        Mirror copy of the positive sample.
        """
        self.data_index = np.concatenate((self.data_index, self.pos_index))
        self.pair_index = np.concatenate((self.pair_index, np.flip(self.pair_index_pos, axis = 1)))

    def get_label(self, index: Optional[np.ndarray] = None, copy: bool = False) -> Optional[np.ndarray]:
        """
        Get `label` according to `index`.

        Parameters
        ----------
        index : Optional[np.ndarray], default=None
            Data index. If None, take `data_index`.

        copy : bool, default=False
            Whether to return `label`.
        """
        if index is None:
            index = self.data_index

        label = np.take(self.label_total, index, 0)
        if copy:
            return label
        else:
            self.label = label



class LabeledDataUnit(LabeledData):
    """
    Labeled data processing class for single set of spots.

    A labeled data unit can be subsequently used to build dataset in a single slice training and validation task.
    Given `adata` and `spot_index`, it can generate spot pairs and obtain features. Preprocessing is an optional step.
    Additionally, it can calculate `distance` between spots and generate labels.

    Parameters
    ----------
    adata : AnnData
        The original data.
    
    neighbor_dis : float
        Cell neighborhood radius.

    spot_index : Optional[np.ndarray], default=None
        The spot subset index of `adata`. If None, `spot_index` is the total spot index of `adata`.
    
    Attributes
    ----------
    adata : AnnData
        The original data.

    neighbor_dis : float
        Cell neighborhood radius.

    spot_index : np.ndarray
        The spot subset index of `adata`.
    
    pair_index_total : np.ndarray
        2D `np.ndarray` of shape :math:`n_pairs` x 2, each row records the spot index of `spot pair`. 
        :math:`n_pairs = n_spots x (n_spots - 1) / 2`. 
        Note that the recorded index is not the `spot_index` in `adata`, but the index of `spot_index`.
        Users can restore the original `pair_index_total` by indexing the `spot_index` using `pair_index_total`.
    
    total_index : np.ndarray
        The total data index.

    distance : np.ndarray
        1D `np.ndarray` of length `n_pairs`, record the distance.

    label_total : np.ndarray
        1D `np.ndarray` of length `n_pairs`, record the label.

    pos_index : np.ndarray
        The data index of positive samples.

    pair_index_pos : np.ndarray
        The spot pair index of positive samples.

    neg_index : np.ndarray
        The data index of negative samples.

    pair_index_neg : np.ndarray
        The spot pair index of negative samples.

    pair_index : np.ndarray
        The selected spot pair index used to build dataset.

    data_index : np.ndarray
        The selected data index used to build dataset.

    count : np.ndarray
        The (preprocessed) count of `adata` subset.
    
    feature : np.ndarray
        The feature generated by `pair_index`.

    label : np.ndarray
        The label generated by `data_index`.
    """
    def spot2pair(self) -> None:
        """
        Generate `pair_index_total` and `total_index`.
        """
        self.pair_index_total = np.array(list(
            combinations(
                range(len(self.spot_index)), 2
            )
        ))
        self.total_index = np.arange(len(self.pair_index_total))

    def get_count(self, preprocess: bool = True, **kwargs) -> None:
        """
        Generate `count`.
        """
        adata_sub = self.adata[self.spot_index].copy()
        if preprocess:
            adata_sub = self.preprocess(adata_sub, **kwargs)

        self.count = adata_sub.to_df().values

    def get_feature(self, index: Optional[np.ndarray] = None, copy: bool = False) -> Optional[np.ndarray]:
        """
        Get `feature` according to `index`.

        Parameters
        ----------
        index : Optional[np.ndarray], default=None
            Spot pair index of shape (N, 2). If None, take `pair_index`.

        copy : bool, default=False
            Whether to return `feature`.
        """
        if index is None:
            index = self.pair_index

        return super().get_feature(index, copy)



class LabeledDataDoublet(LabeledData):
    """
    Labeled data processing class for two sets of spots.

    A labeled data doublet can be subsequently used to build dataset in a validation task 
    between two subsets of one slice. Given `adata` and `spot_index`, it can generate spot pairs and obtain features. 
    Preprocessing is an optional step. Additionally, it can calculate `distance` between spots and generate labels.

    Parameters
    ----------
    adata : AnnData
        The original data.
    
    neighbor_dis : float
        Cell neighborhood radius.

    spot_index1 : np.ndarray
        The first spot subset index of `adata`.
    
    spot_index2 : np.ndarray
        The second spot subset index of `adata`.
    
    Attributes
    ----------
    adata : AnnData
        The original data.

    neighbor_dis : float
        Cell neighborhood radius.

    spot_index : list[np.ndarray, np.ndarray]
        The two spot subsets index of `adata`.
    
    pair_index_total : np.ndarray
        2D `np.ndarray` of shape :math:`n_pairs` x 2, each row records the spot index of `spot pair`. 
        :math:`n_pairs = n_spots x (n_spots - 1) / 2`. 
        Note that the recorded index is exactly the `spot_index` in `adata`.
    
    total_index : np.ndarray
        The total data index.

    distance : np.ndarray
        1D `np.ndarray` of length `n_pairs`, record the distance.

    label_total : np.ndarray
        1D `np.ndarray` of length `n_pairs`, record the label.
    
    pos_index : np.ndarray
        The data index of positive samples.
    
    pair_index_pos : np.ndarray
        The spot pair index of positive samples.

    neg_index : np.ndarray
        The data index of negative samples.

    pair_index_neg : np.ndarray
        The spot pair index of negative samples.

    pair_index : np.ndarray
        The selected spot pair index used to build dataset.

    data_index : np.ndarray
        The selected data index used to build dataset.

    count : np.ndarray
        The (preprocessed) count of `adata` subset.
    
    feature : np.ndarray
        The feature generated by `pair_index`.

    label : np.ndarray
        The label generated by `data_index`.
    """
    def __init__(
        self,
        adata: AnnData, 
        neighbor_dis: float, 
        spot_index1: np.ndarray,
        spot_index2: np.ndarray
    ) -> None:
        self.adata = adata
        self.neighbor_dis = neighbor_dis
        self.spot_index = [spot_index1, spot_index2]
        self.spot2pair()

    def spot2pair(self) -> None:
        """
        Generate `pair_index_total` and `total_index`.
        """
        # 注意这里不是从头编号
        self.pair_index_total = np.array(list(
            product(
                self.spot_index[0], self.spot_index[1]
            )
        ))
        self.total_index = np.arange(len(self.pair_index_total))
    
    def get_count(self, preprocess = True, **kwargs) -> None:
        """
        Generate `count`.
        """
        # 分别进行scale
        adata1_sub = self.adata[self.spot_index[0]].copy()
        if preprocess:
            adata1_sub = self.preprocess(adata1_sub, **kwargs)
        
        adata2_sub = self.adata[self.spot_index[1]].copy()
        if preprocess:
            adata2_sub = self.preprocess(adata2_sub, **kwargs)

        count1 = adata1_sub.to_df().values
        count2 = adata2_sub.to_df().values
        count = np.empty((self.adata.shape[0], count1.shape[1]))
        count[self.spot_index[0]] = count1
        count[self.spot_index[1]] = count2
        self.count = count
        # 同时scale
        # adata = self.adata
        # if preprocess:
        #     adata = self.preprocess(adata, **kwargs)

        # self.count = adata.to_df().values

    def calc_distance(self) -> None:
        """
        Calculate `distance`.
        """
        self.distance = utils.distance(self.adata, pair_index = self.pair_index_total)

        self.label_total = self.distance <= self.neighbor_dis

    def get_feature(self, index: Optional[np.ndarray] = None, copy: bool = False):
        """
        Get `feature` according to `index`.

        Parameters
        ----------
        index : Optional[np.ndarray], default=None
            Spot pair index of shape (N, 2). If None, take `pair_index`.

        copy : bool, default=False
            Whether to return `feature`.
        """
        if index is None:
            index = self.pair_index

        return super().get_feature(index, copy)


